import { Request, Response } from 'express';
import { AppDataSource } from '../config/database';
import { Game, GameMode, GameStatus } from '../entities/Game';
import { GameParticipant } from '../entities/GameParticipant';
import { User } from '../entities/User';
import { Question } from '../entities/Question';
import { Answer } from '../entities/Answer';
import { Event } from '../entities/Event';

const gameRepository = AppDataSource.getRepository(Game);
const participantRepository = AppDataSource.getRepository(GameParticipant);
const userRepository = AppDataSource.getRepository(User);
const questionRepository = AppDataSource.getRepository(Question);
const answerRepository = AppDataSource.getRepository(Answer);
const eventRepository = AppDataSource.getRepository(Event);

// In-memory map to track per-game team scores (non-persistent)
const gameTeamScores: Map<string, Map<string, number>> = new Map();

// Import emit helper
import { emitToGame } from '../socket/game-socket';

/**
 * Generate a unique 6-character room code
 */
function generateRoomCode(): string {
  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for (let i = 0; i < 6; i++) {
    code += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return code;
}

/**
 * Create a new Geoparty game session (Individual mode)
 * POST /api/game/geoparty/create
 */
export async function createGeopartyGame(req: Request, res: Response): Promise<void> {
  try {
    const { name, eventId, totalQuestions } = req.body;

    // Validate event if provided
    if (eventId) {
      const event = await eventRepository.findOne({ where: { id: eventId } });
      if (!event) {
        res.status(404).json({
          success: false,
          message: 'Event not found',
        });
        return;
      }
    }

    // Generate unique room code
    let roomCode: string;
    let isUnique = false;
    let attempts = 0;
    const maxAttempts = 10;

    while (!isUnique && attempts < maxAttempts) {
      roomCode = generateRoomCode();
      const existingGame = await gameRepository.findOne({ where: { roomCode } });
      if (!existingGame) {
        isUnique = true;
      }
      attempts++;
    }

    if (!isUnique) {
      res.status(500).json({
        success: false,
        message: 'Failed to generate unique room code',
      });
      return;
    }

    // Create game
    const game = gameRepository.create({
      name: name || 'Geoparty Game',
      roomCode: roomCode!,
      mode: GameMode.GEOPARTY,
      status: GameStatus.WAITING,
      eventId: eventId || null,
      usedQuestionIds: [],
      totalQuestions: totalQuestions || 20, // Geoparty usually has more questions
    });

    await gameRepository.save(game);

    res.status(201).json({
      success: true,
      data: {
        game: {
          id: game.id,
          roomCode: game.roomCode,
          name: game.name,
          mode: game.mode,
          status: game.status,
          totalQuestions: game.totalQuestions,
        },
      },
      message: 'Geoparty game created successfully',
    });
  } catch (error) {
    console.error('Create Geoparty game error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to create Geoparty game',
    });
  }
}

/**
 * Join game as individual player (no team) - using roomCode
 * POST /api/game/geoparty/:roomCode/join
 */
export async function joinGeopartyGame(req: Request, res: Response): Promise<void> {
  try {
    const { roomCode } = req.params;
    const { userId } = req.body;

    // Find game by roomCode instead of UUID
    const game = await gameRepository.findOne({ where: { roomCode: roomCode.toUpperCase() } });
    if (!game) {
      res.status(404).json({
        success: false,
        message: 'Game not found',
      });
      return;
    }

    // Support guest users: guest IDs are generated by the frontend and are not UUIDs.
    // If the provided userId is not a valid UUID, skip the users lookup and allow a guest participant.
    let user = null;
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    if (typeof userId === 'string' && uuidRegex.test(userId)) {
      user = await userRepository.findOne({ where: { id: userId } });
      if (!user) {
        res.status(404).json({
          success: false,
          message: 'User not found',
        });
        return;
      }
    } else {
      // treat as guest: proceed without querying users table
      user = null;
    }

    // Check if user already joined
    const existingParticipant = await participantRepository.findOne({
      where: { gameId: game.id, userId },
    });

    if (existingParticipant) {
      res.status(400).json({
        success: false,
        message: 'User already joined this game',
      });
      return;
    }

    // Create participant (no teamId for Geoparty)
    const participant = participantRepository.create({
      userId,
      gameId: game.id,
      score: 0,
      correctAnswers: 0,
      totalAnswers: 0,
      streak: 0,
    });

    await participantRepository.save(participant);

    res.json({
      success: true,
      data: {
        participant: {
          id: participant.id,
          userId: participant.userId,
          score: participant.score,
        },
        game: {
          id: game.id,
          roomCode: game.roomCode,
          name: game.name,
          status: game.status,
        },
      },
      message: 'Joined game successfully',
    });
  } catch (error) {
    console.error('Join Geoparty game error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to join game',
    });
  }
}

/**
 * Start Geoparty game
 * POST /api/game/geoparty/:roomCode/start
 */
export async function startGeopartyGame(req: Request, res: Response): Promise<void> {
  try {
    const { roomCode } = req.params;

    const game = await gameRepository.findOne({
      where: { roomCode: roomCode.toUpperCase() },
      relations: ['event'],
    });

    if (!game) {
      res.status(404).json({
        success: false,
        message: 'Game not found',
      });
      return;
    }

    game.status = GameStatus.IN_PROGRESS;
    game.startedAt = new Date();
    await gameRepository.save(game);

    res.json({
      success: true,
      data: {
        game: {
          id: game.id,
          roomCode: game.roomCode,
          status: game.status,
          startedAt: game.startedAt,
        },
      },
      message: 'Game started successfully',
    });
  } catch (error) {
    console.error('Start Geoparty game error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to start game',
    });
  }
}

/**
 * Player selects a question by category (Geoparty-specific)
 * POST /api/game/geoparty/:roomCode/select-question
 */
export async function selectQuestion(req: Request, res: Response): Promise<void> {
  try {
    const { roomCode } = req.params;
    const { category } = req.body;

    const game = await gameRepository.findOne({ where: { roomCode: roomCode.toUpperCase() } });
    if (!game) {
      res.status(404).json({
        success: false,
        message: 'Game not found',
      });
      return;
    }

    // Get random question from selected category
    const queryBuilder = questionRepository.createQueryBuilder('question');

    // Filter by category
    queryBuilder.where('question.category = :category', { category });

    // Filter by game mode (GEOPARTY only)
    queryBuilder.andWhere('(question.gameMode = :mode OR question.gameMode IS NULL)', { 
      mode: GameMode.GEOPARTY 
    });

    // Filter by event if specified
    if (game.eventId) {
      queryBuilder.andWhere('question.eventId = :eventId', { eventId: game.eventId });
    }

    // Exclude already used questions
    if (game.usedQuestionIds && game.usedQuestionIds.length > 0) {
      queryBuilder.andWhere('question.id NOT IN (:...usedIds)', {
        usedIds: game.usedQuestionIds,
      });
    }

    const questions = await queryBuilder.getMany();

    if (questions.length === 0) {
      res.status(404).json({
        success: false,
        message: 'No available questions in this category',
      });
      return;
    }

    // Pick random question
    const randomIndex = Math.floor(Math.random() * questions.length);
    const selectedQuestion = questions[randomIndex];

    // Add to used questions
    game.usedQuestionIds = [...(game.usedQuestionIds || []), selectedQuestion.id];
    await gameRepository.save(game);

    res.json({
      success: true,
      data: {
        question: selectedQuestion,
      },
    });
  } catch (error) {
    console.error('Select question error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to select question',
    });
  }
}

/**
 * Reserve a cell (categoryId + rowIndex) for a game and return a question
 * POST /api/game/geoparty/:roomCode/reserve-cell
 * Body: { categoryId: string, rowIndex: number, participantId?: string, teamId?: string }
 */
export async function reserveCell(req: Request, res: Response): Promise<void> {
  try {
    const { roomCode } = req.params;
    const { categoryId, rowIndex, participantId, teamId } = req.body;

    const game = await gameRepository.findOne({ where: { roomCode: roomCode.toUpperCase() } });
    if (!game) {
      res.status(404).json({ success: false, message: 'Game not found' });
      return;
    }

    // For now, reservation is logical: we will pick a question and mark it used immediately
    // Get questions filtered like selectQuestion but narrowed by category
    const queryBuilder = questionRepository.createQueryBuilder('question');
    queryBuilder.where('question.category = :category', { category: categoryId });
    queryBuilder.andWhere('(question.gameMode = :mode OR question.gameMode IS NULL)', { mode: GameMode.GEOPARTY });
    if (game.eventId) {
      queryBuilder.andWhere('question.eventId = :eventId', { eventId: game.eventId });
    }
    if (game.usedQuestionIds && game.usedQuestionIds.length > 0) {
      queryBuilder.andWhere('question.id NOT IN (:...usedIds)', { usedIds: game.usedQuestionIds });
    }

    const questions = await queryBuilder.getMany();
    if (questions.length === 0) {
      res.status(404).json({ success: false, message: 'No available questions in this category' });
      return;
    }

    const randomIndex = Math.floor(Math.random() * questions.length);
    const selectedQuestion = questions[randomIndex];

    // Mark selected question as used for the game
    game.usedQuestionIds = [...(game.usedQuestionIds || []), selectedQuestion.id];
    await gameRepository.save(game);

    // Emit a websocket event to notify others that the cell was reserved
    emitToGame(game.roomCode, 'cell-reserved', {
      categoryId,
      rowIndex,
      questionId: selectedQuestion.id,
      reservedBy: participantId || null,
      teamId: teamId || null,
    });

    res.json({ success: true, data: { question: selectedQuestion } });
  } catch (error) {
    console.error('Reserve cell error:', error);
    res.status(500).json({ success: false, message: 'Failed to reserve cell' });
  }
}

/**
 * Submit answer to a Geoparty question
 * POST /api/game/geoparty/:roomCode/answer
 */
export async function submitGeopartyAnswer(req: Request, res: Response): Promise<void> {
  try {
    const { roomCode } = req.params;
    const { participantId, questionId, selectedAnswer, timeRemaining, teamId } = req.body;

    const game = await gameRepository.findOne({ where: { roomCode: roomCode.toUpperCase() } });
    if (!game) {
      res.status(404).json({
        success: false,
        message: 'Game not found',
      });
      return;
    }

    const participant = await participantRepository.findOne({
      where: { id: participantId, gameId: game.id },
    });

    if (!participant) {
      res.status(404).json({
        success: false,
        message: 'Participant not found',
      });
      return;
    }

    const question = await questionRepository.findOne({
      where: { id: questionId },
    });

    if (!question) {
      res.status(404).json({
        success: false,
        message: 'Question not found',
      });
      return;
    }

    // Check if answer is correct
    const isCorrect = selectedAnswer === question.correctAnswer;
    
    // Calculate points (with time bonus)
    let points = 0;
    if (isCorrect) {
      const timeBonus = Math.max(0, (timeRemaining / question.timeLimit) * 50);
      points = question.points + Math.floor(timeBonus);
      
      // Apply streak bonus
      const newStreak = participant.streak + 1;
      if (newStreak % 3 === 0) {
        points += 50; // Streak bonus every 3 correct answers
      }
      participant.streak = newStreak;
    } else {
      participant.streak = 0; // Reset streak on wrong answer
    }

    // Create answer record
    const answer = answerRepository.create({
      participantId: participant.id,
      questionId: question.id,
      selectedAnswer,
      isCorrect,
      points,
      timeRemaining,
    });

    await answerRepository.save(answer);

    // Update participant stats
    participant.score += points;
    participant.totalAnswers++;
    if (isCorrect) {
      participant.correctAnswers++;
    }
    await participantRepository.save(participant);

    // If teamId provided, update in-memory team scores for this game
    let teamScoresResponse: any = null;
    if (teamId) {
      const gameKey = game.id;
      if (!gameTeamScores.has(gameKey)) {
        gameTeamScores.set(gameKey, new Map<string, number>());
      }
      const map = gameTeamScores.get(gameKey)!;
      const prev = map.get(teamId) || 0;
      const added = isCorrect ? points : 0;
      map.set(teamId, prev + added);

      // build leaderboard for teams (simple array)
      const teamLeaderboard = Array.from(map.entries())
        .map(([tid, score]) => ({ teamId: tid, score }))
        .sort((a, b) => b.score - a.score);

      // Emit team-score-updated event
      emitToGame(game.roomCode, 'team-score-updated', { teamLeaderboard });

      teamScoresResponse = teamLeaderboard;
    }

    // Mark question as used in game
    if (!game.usedQuestionIds) {
      game.usedQuestionIds = [];
    }
    if (!game.usedQuestionIds.includes(questionId)) {
      game.usedQuestionIds.push(questionId);
      await gameRepository.save(game);
    }

    const wrongAnswers = participant.totalAnswers - participant.correctAnswers;

    res.json({
      success: true,
      data: {
        answer: {
          isCorrect,
          points,
          correctAnswer: question.correctAnswer,
        },
        participant: {
          score: participant.score,
          correctAnswers: participant.correctAnswers,
          wrongAnswers,
          streak: participant.streak,
        },
        teamScores: teamScoresResponse,
      },
    });
  } catch (error) {
    console.error('Submit Geoparty answer error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to submit answer',
    });
  }
}

/**
 * Get Geoparty game leaderboard (individual players)
 * GET /api/game/geoparty/:roomCode/leaderboard
 */
export async function getGeopartyLeaderboard(req: Request, res: Response): Promise<void> {
  try {
    const { roomCode } = req.params;

    const game = await gameRepository.findOne({ where: { roomCode: roomCode.toUpperCase() } });
    if (!game) {
      res.status(404).json({
        success: false,
        message: 'Game not found',
      });
      return;
    }

    const participants = await participantRepository.find({
      where: { gameId: game.id },
      relations: ['user'],
      order: { score: 'DESC' },
    });

    const leaderboard = participants.map((p, index) => ({
      rank: index + 1,
      participantId: p.id,
      userId: p.userId,
      userName: p.user?.name || 'Unknown',
      score: p.score,
      correctAnswers: p.correctAnswers,
      wrongAnswers: p.totalAnswers - p.correctAnswers,
      streak: p.streak,
    }));

    res.json({
      success: true,
      data: {
        leaderboard,
      },
    });
  } catch (error) {
    console.error('Get Geoparty leaderboard error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get leaderboard',
    });
  }
}

/**
 * Get Geoparty game status
 * GET /api/game/geoparty/:roomCode
 */
export async function getGeopartyGame(req: Request, res: Response): Promise<void> {
  try {
    const { roomCode } = req.params;

    const game = await gameRepository.findOne({
      where: { roomCode: roomCode.toUpperCase() },
      relations: ['event'],
    });

    if (!game) {
      res.status(404).json({
        success: false,
        message: 'Game not found',
      });
      return;
    }

    const participants = await participantRepository.find({
      where: { gameId: game.id },
      relations: ['user'],
    });

    const usedCount = game.usedQuestionIds?.length || 0;

    res.json({
      success: true,
      data: {
        game: {
          id: game.id,
          name: game.name,
          mode: game.mode,
          status: game.status,
          questionsAnswered: usedCount,
          totalQuestions: game.totalQuestions,
          startedAt: game.startedAt,
          finishedAt: game.finishedAt,
        },
        participants: participants.length,
        participantsList: participants.map(p => ({
          id: p.id,
          userName: p.user?.name,
          score: p.score,
        })),
      },
    });
  } catch (error) {
    console.error('Get Geoparty game error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get game',
    });
  }
}
